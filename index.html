<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>永城七采区 - 多层地质结构 VR 浏览器</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        body, html { overflow: hidden; width: 100%; height: 100%; margin: 0; background: #111; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 8px; font-family: sans-serif; max-width: 300px; }
        .layer-item { margin: 5px 0; font-size: 12px; }
        input[type="range"] { width: 100%; }
    </style>
</head>
<body>
    <div id="ui">
        <strong>多层地质结构加载器</strong><br>
        <p style="font-size: 12px;">请多选并上传文件 (如 h22, h32, hl8):</p>
        <input type="file" id="fileInput" accept=".txt" multiple>
        
        <div style="margin-top:15px;">
            <label>垂直拉伸倍数: <span id="zVal">5</span></label>
            <input type="range" id="zScale" min="1" max="20" value="5">
        </div>

        <div id="layerList" style="margin-top:10px; border-top: 1px solid #444; padding-top: 10px;">
            </div>
        <div id="status" style="margin-top:10px; color: #0f0;">等待导入...</div>
    </div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let scene, camera;
        let layers = []; // 存储所有加载的层
        let zFactor = 5;

        const createScene = async function () {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.05);

            camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 3, 500, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            
            new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            
            // 开启 VR
            await scene.createDefaultXRExperienceAsync({ floorMeshes: [] });
            return scene;
        };

        // 颜色库，用于区分不同地层
        const colorPalette = [
            new BABYLON.Color4(1, 0.5, 0, 1),   // 橙色 (可能是煤层1)
            new BABYLON.Color4(0, 0.8, 1, 1),   // 天蓝色 (可能是灰岩)
            new BABYLON.Color4(0.8, 0.2, 1, 1), // 紫色
            new BABYLON.Color4(0.2, 1, 0.2, 1), // 绿色
            new BABYLON.Color4(1, 1, 1, 1)      // 白色
        ];

        async function parseFile(file, color, index) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const lines = e.target.result.split('\n');
                    const points = [];
                    for (let line of lines) {
                        const parts = line.trim().split(/\s+/);
                        if (parts.length >= 3) {
                            const x = parseFloat(parts[0]), y = parseFloat(parts[1]), z = parseFloat(parts[2]);
                            if (!isNaN(x) && x > 10000) points.push({ x, y, z });
                        }
                    }
                    resolve({ name: file.name, points, color });
                };
                reader.readAsText(file);
            });
        }

        async function updateVisualization() {
            if (layers.length === 0) return;

            // 清除旧模型
            scene.meshes.filter(m => m.name.startsWith("layer_")).forEach(m => m.dispose());

            // 计算所有层的统一中心点
            let allMinX = Math.min(...layers.map(l => Math.min(...l.points.map(p => p.x))));
            let allMaxX = Math.max(...layers.map(l => Math.max(...l.points.map(p => p.x))));
            let allMinY = Math.min(...layers.map(l => Math.min(...l.points.map(p => p.y))));
            let allMaxY = Math.max(...layers.map(l => Math.max(...l.points.map(p => p.y))));
            let centerX = (allMinX + allMaxX) / 2;
            let centerY = (allMinY + allMaxY) / 2;

            layers.forEach((layer, idx) => {
                const pcs = new BABYLON.PointsCloudSystem("layer_" + idx, 3, scene);
                pcs.addPoints(layer.points.length, (particle, i) => {
                    const p = layer.points[i];
                    particle.position = new BABYLON.Vector3(
                        p.x - centerX,
                        p.z * (zFactor / 10), // 使用拉伸倍数
                        p.y - centerY
                    );
                    particle.color = layer.color;
                });
                pcs.buildMeshAsync();
            });

            camera.radius = (allMaxX - allMinX) * 0.8;
            document.getElementById("status").innerText = `已加载 ${layers.length} 个地层`;
        }

        document.getElementById('fileInput').addEventListener('change', async function(e) {
            const files = Array.from(e.target.files);
            layers = [];
            document.getElementById("layerList").innerHTML = "";
            
            for (let i = 0; i < files.length; i++) {
                const color = colorPalette[i % colorPalette.length];
                const data = await parseFile(files[i], color, i);
                layers.push(data);
                
                // 更新 UI 列表
                const item = document.createElement("div");
                item.className = "layer-item";
                item.style.color = `rgb(${color.r*255}, ${color.g*255}, ${color.b*255})`;
                item.innerText = `● ${data.name} (${data.points.length} 点)`;
                document.getElementById("layerList").appendChild(item);
            }
            updateVisualization();
        });

        document.getElementById('zScale').addEventListener('input', function(e) {
            zFactor = e.target.value;
            document.getElementById("zVal").innerText = zFactor;
            updateVisualization();
        });

        createScene().then(() => {
            engine.runRenderLoop(() => scene.render());
        });
        window.addEventListener("resize", () => engine.resize());
    </script>
</body>
</html>