<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>永城七采区 - 3D体积模型(Block Model)</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        body, html { overflow: hidden; width: 100%; height: 100%; margin: 0; background: #050505; color: white; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(20,20,20,0.9); padding: 20px; border-radius: 12px; font-family: 'Segoe UI', sans-serif; width: 300px; border: 1px solid #333; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        .control-group { margin: 15px 0; }
        input[type="range"] { width: 100%; }
        .hint { font-size: 11px; color: #888; margin-top: 5px; }
        button { background: #444; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; width: 100%; }
        button:hover { background: #666; }
    </style>
</head>
<body>
    <div id="ui">
        <strong style="font-size: 18px;">地质体积建模器</strong>
        <div class="control-group">
            <label>1. 上传地层数据(多选):</label>
            <input type="file" id="fileInput" accept=".txt" multiple>
            <div class="hint">按住 Ctrl 选择 h22, h32, hl8...</div>
        </div>
        <div class="control-group">
            <label>2. 垂直夸大系数: <span id="zVal">10</span></label>
            <input type="range" id="zScale" min="1" max="100" value="10">
        </div>
        <div class="control-group">
            <label>3. 地层透明度: <span id="alphaVal">0.8</span></label>
            <input type="range" id="alpha" min="1" max="10" value="8">
        </div>
        <button id="resetView">重置观察位置</button>
        <div id="log" style="font-size: 12px; color: #0f0; margin-top: 15px; max-height: 80px; overflow-y: auto;">等待数据读取...</div>
    </div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let scene, camera;
        let layers = []; 
        let zFactor = 10;
        let opacity = 0.8;

        function updateLog(msg) {
            document.getElementById("log").innerHTML += `<div>> ${msg}</div>`;
        }

        const createScene = async function () {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.01, 0.01, 0.02);

            camera = new BABYLON.ArcRotateCamera("camera", -Math.PI/4, Math.PI/3, 500, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 1.0;

            // 开启 VR 模式
            await scene.createDefaultXRExperienceAsync({ floorMeshes: [] });
            return scene;
        };

        // 统一解析地层文件
        async function parseFile(file) {
            return new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => {
                    const lines = e.target.result.split('\n');
                    let pts = [];
                    lines.forEach(line => {
                        const parts = line.trim().split(/\s+/);
                        if(parts.length >= 3) {
                            const x = parseFloat(parts[0]), y = parseFloat(parts[1]), z = parseFloat(parts[2]);
                            if(x > 100000) pts.push({x, y, z});
                        }
                    });
                    resolve({ name: file.name, points: pts });
                };
                reader.readAsText(file);
            });
        }

        // 核心渲染逻辑：生成“体积感”
        async function buildVolume() {
            if (layers.length === 0) return;
            
            // 销毁旧物体
            scene.meshes.forEach(m => { if(m.id.startsWith("vol_")) m.dispose(); });

            // 计算所有地层的边界
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            layers.forEach(l => l.points.forEach(p => {
                if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x;
                if(p.y < minY) minY = p.y; if(p.y > maxY) maxY = p.y;
            }));
            const centerX = (minX + maxX) / 2, centerY = (minY + maxY) / 2;

            // 为了显示“体”，我们对每个地层点位生成一个“块”
            layers.forEach((layer, idx) => {
                // 为不同层创建材质
                const mat = new BABYLON.StandardMaterial("mat_" + idx, scene);
                const hue = (idx * 137) % 360; // 自动分配色调
                mat.diffuseColor = BABYLON.Color3.FromHSV(hue, 0.8, 1);
                mat.alpha = opacity;
                mat.backFaceCulling = false;

                // 使用 SPS (Solid Particle System) 来渲染大量“体块”
                const sps = new BABYLON.SolidParticleSystem("vol_" + idx, scene);
                const box = BABYLON.MeshBuilder.CreateBox("b", { size: 1.5 });
                sps.addShape(box, layer.points.length);
                box.dispose();

                sps.buildMesh();
                sps.mesh.material = mat;

                sps.initParticles = () => {
                    for (let p = 0; p < sps.nbParticles; p++) {
                        const data = layer.points[p];
                        const part = sps.particles[p];
                        part.position.x = data.x - centerX;
                        part.position.z = data.y - centerY;
                        part.position.y = data.z * (zFactor / 10);
                        
                        // 让块在垂直方向上拉伸，形成连接感
                        part.scaling.y = 5; 
                        part.scaling.x = 2;
                        part.scaling.z = 2;
                    }
                };
                sps.initParticles();
                sps.setParticles();
            });

            updateLog("体积化构建完成");
            camera.radius = (maxX - minX) * 0.5;
            camera.setTarget(BABYLON.Vector3.Zero());
        }

        document.getElementById('fileInput').onchange = async (e) => {
            const files = Array.from(e.target.files);
            layers = [];
            for(let f of files) {
                const d = await parseFile(f);
                if(d.points.length > 0) layers.push(d);
            }
            buildVolume();
        };

        document.getElementById('zScale').oninput = (e) => {
            zFactor = e.target.value;
            document.getElementById("zVal").innerText = zFactor;
            buildVolume();
        };

        document.getElementById('alpha').oninput = (e) => {
            opacity = e.target.value / 10;
            document.getElementById("alphaVal").innerText = opacity;
            buildVolume();
        };

        document.getElementById('resetView').onclick = () => camera.setTarget(BABYLON.Vector3.Zero());

        createScene().then(() => engine.runRenderLoop(() => scene.render()));
        window.addEventListener("resize", () => engine.resize());
    </script>
</body>
</html>