<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>XR地质沉浸式系统 - 研究原型</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        body, html { overflow: hidden; width: 100%; height: 100%; margin: 0; background: #000; }
        #renderCanvas { width: 100%; height: 100%; }
        #overlay { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; font-family: sans-serif; pointer-events: none; }
    </style>
</head>
<body>
    <div id="overlay">
        <strong>研究目标实现：沉浸式分析系统</strong><br>
        1. 剖切面：实时观察地层内部结构<br>
        2. 拾取：点击获取地质属性 (X,Y,Z,Depth)<br>
        3. 性能：Thin Instance GPU 加速
    </div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let scene, camera, clipPlane;
        let layersData = [];

        const createScene = async function () {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.1, 1);

            // 1. 相机与光照
            camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/3, 400, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            // 2. 实现开题报告中的“动态剖切” (Slicing Plane) 
            // 创建一个剖切面
            clipPlane = new BABYLON.Plane(0, 1, 0, 0); // 初始在Y轴
            scene.clipPlane = clipPlane;

            // 3. XR 支持 - 对应“沉浸式可视化”目标 
            await scene.createDefaultXRExperienceAsync({ floorMeshes: [] });

            // 4. GUI 控制剖切深度
            const adt = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            const panel = new BABYLON.GUI.StackPanel();
            panel.width = "220px";
            panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            adt.addControl(panel);

            const label = new BABYLON.GUI.TextBlock();
            label.text = "动态剖切高度"; label.height = "30px"; label.color = "white";
            panel.addControl(label);

            const slider = new BABYLON.GUI.Slider();
            slider.minimum = -200; slider.maximum = 500; slider.value = 500;
            slider.height = "20px"; slider.width = "200px";
            slider.onValueChangedObservable.add((val) => {
                scene.clipPlane = new BABYLON.Plane(0, -1, 0, val); // 动态改变剖切高度
            });
            panel.addControl(slider);

            return scene;
        };

        // 5. 数据处理：对应“数据预处理”技术路线 
        async function loadAndBuild(files) {
            // 清理旧模型
            scene.meshes.filter(m => m.name.includes("layer")).forEach(m => m.dispose());
            
            for (let i = 0; i < files.length; i++) {
                const text = await files[i].text();
                const pts = text.split('\n').map(l => l.trim().split(/\s+/))
                                .filter(p => p.length >= 3 && parseFloat(p[0]) > 100000)
                                .map(p => ({ x: parseFloat(p[0]), y: parseFloat(p[1]), z: parseFloat(p[2]) }));

                buildLayer(pts, i, files[i].name);
            }
        }

        // 6. 高性能渲染：实现“性能约束机理研究” 
        function buildLayer(points, index, name) {
            const center = { x: 441000, y: 3755000 }; // 简化中心点
            const baseBox = BABYLON.MeshBuilder.CreateBox("layer_"+index, { size: 4 }, scene);
            
            const mat = new BABYLON.StandardMaterial("mat_"+index, scene);
            mat.diffuseColor = BABYLON.Color3.FromHSV(index * 40, 0.8, 1);
            baseBox.material = mat;

            const matricesData = new Float32Array(16 * points.length);
            points.forEach((p, i) => {
                const matrix = BABYLON.Matrix.Translation(p.x - center.x, p.z, p.y - center.y);
                matrix.copyToArray(matricesData, i * 16);
            });

            baseBox.thinInstanceSetBuffer("matrix", matricesData, 16);
            
            // 7. 属性拾取：实现“属性信息关联展示” 
            baseBox.metadata = { fileName: name, pointCount: points.length };
        }

        // 交互拾取逻辑
        window.addEventListener("click", () => {
            const pick = scene.pick(scene.pointerX, scene.pointerY);
            if (pick.hit && pick.pickedMesh.name.includes("layer")) {
                const meta = pick.pickedMesh.metadata;
                alert(`选中地层: ${meta.fileName}\n数据点数: ${meta.pointCount}`);
            }
        });

        createScene().then(() => {
            engine.runRenderLoop(() => scene.render());
            // 模拟文件上传（实际应用中需通过 input 触发）
            // loadAndBuild(uploadedFiles); 
        });

        window.addEventListener("resize", () => engine.resize());
    </script>
</body>
</html>