<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>永城七采区 - 地质 VR 场景预览</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        body, html { overflow: hidden; width: 100%; height: 100%; margin: 0; padding: 0; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 10; background: rgba(255,255,255,0.8); padding: 15px; border-radius: 8px; font-family: Arial; }
    </style>
</head>
<body>
    <div id="ui">
        <h3>永城七采区地质模型生成器</h3>
        <p>请选择一个 .txt 文件 (如 h22_hdk1.txt):</p>
        <input type="file" id="fileInput" accept=".txt">
        <div id="status">等待导入数据...</div>
    </div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let scene, pcs;

        const createScene = async function () {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.1);

            // 1. 相机设置（通用相机，支持 VR）
            const camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, 50, -100), scene);
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.attachControl(canvas, true);

            // 2. 灯光
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;

            // 3. 开启 WebXR (VR 支持)
            try {
                const xrHelper = await scene.createDefaultXRExperienceAsync({
                    floorMeshes: [] // 如果有地面网格可以放这里
                });
                console.log("VR 准备就绪");
            } catch (e) {
                console.log("当前环境不支持 WebXR");
            }

            return scene;
        };

        // 数据解析核心逻辑
        async function processFileData(text) {
            const lines = text.split('\n');
            const points = [];
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

            for (let line of lines) {
                line = line.trim();
                // 跳过文件头
                if (!line || line.startsWith('!') || line.startsWith('FMASCI') || line.startsWith('-')) continue;

                const parts = line.split(/\s+/);
                if (parts.length >= 3) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    const z = parseFloat(parts[2]);

                    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                        points.push({ x, y, z });
                        // 计算边界用于平移坐标系
                        if (x < minX) minX = x; if (x > maxX) maxX = x;
                        if (y < minY) minY = y; if (y > maxY) maxY = y;
                    }
                }
            }

            if (points.length === 0) return;

            // 计算中心点偏移量
            const offsetX = (minX + maxX) / 2;
            const offsetY = (minY + maxY) / 2;

            // 如果之前有模型，先销毁
            if (pcs) pcs.dispose();

            // 使用 Babylon 的点云系统 (PCS) 高效渲染
            pcs = new BABYLON.PointsCloudSystem("pcs", 2, scene);

            const addPoints = (particle, i, s) => {
                const p = points[i];
                // 转换坐标：
                // Babylon Y轴是垂直向上的，所以原始Y(北向)对应Babylon的Z，原始Z(深度)对应Babylon的Y
                particle.position = new BABYLON.Vector3(
                    (p.x - offsetX), 
                    p.z * 0.1, // 深度通常较小，这里乘0.1缩小比例，或者根据需要调整
                    (p.y - offsetY)
                );
                
                // 根据深度上色 (颜色映射)
                const colorRatio = (p.z + 1000) / 1000; // 假设深度在-1000到0之间
                particle.color = new BABYLON.Color4(1 - colorRatio, colorRatio, 0.5, 1);
            };

            pcs.addPoints(points.length, addPoints);
            await pcs.buildMeshAsync();
            
            document.getElementById("status").innerText = `成功加载 ${points.length} 个数据点`;
        }

        // 文件读取监听
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                processFileData(e.target.result);
            };
            reader.readAsText(file);
        });

        createScene().then(() => {
            engine.runRenderLoop(() => {
                scene.render();
            });
        });

        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>
</body>
</html>