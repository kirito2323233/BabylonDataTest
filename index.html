<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ°¸åŸä¸ƒé‡‡åŒº - æé€Ÿä½“ç§¯å»ºæ¨¡ç‰ˆ</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        body, html { overflow: hidden; width: 100%; height: 100%; margin: 0; background: #000; color: #eee; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; font-family: sans-serif; width: 280px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; margin-top: 10px; }
        input[type="range"] { width: 100%; margin: 5px 0; }
        button { background: #3366ff; color: white; border: none; padding: 8px; border-radius: 4px; width: 100%; cursor: pointer; margin-top: 10px; }
    </style>
</head>
<body>
    <div id="ui">
        <strong>ğŸš€ é«˜æ€§èƒ½åœ°è´¨æµè§ˆå™¨</strong>
        <input type="file" id="fileInput" accept=".txt" multiple style="margin-top:10px; width:100%;">
        
        <div class="slider-label"><span>å‚ç›´å¤¸å¤§:</span><b id="zVal">10</b></div>
        <input type="range" id="zScale" min="1" max="100" value="10">

        <div class="slider-label"><span>é‡‡æ ·ç²¾åº¦ (1=æœ€é«˜):</span><b id="sVal">2</b></div>
        <input type="range" id="sample" min="1" max="10" value="2">

        <div class="slider-label"><span>æ–¹å—å°ºå¯¸:</span><b id="bVal">3</b></div>
        <input type="range" id="bSize" min="1" max="10" value="3">

        <button id="resetCam">å¯¹ç„¦æ¨¡å‹</button>
        <div id="info" style="font-size: 11px; color: #888; margin-top: 10px;">çŠ¶æ€: ç­‰å¾…æ•°æ®...</div>
    </div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: false, stencil: false });
        let scene, camera;
        let layers = [];
        let zFactor = 10;
        let step = 2; // é‡‡æ ·æ­¥é•¿
        let boxSize = 3;

        const createScene = async function () {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);
            
            // åŸºç¡€å…‰ç…§ä¼˜åŒ–
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 1.0;

            camera = new BABYLON.ArcRotateCamera("camera", 0, 1, 500, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 10;

            // å¼€å¯ VR æ¨¡å¼
            await scene.createDefaultXRExperienceAsync();
            return scene;
        };

        async function loadFiles(files) {
            layers = [];
            document.getElementById("info").innerText = "è§£æä¸­...";
            
            for (let f of files) {
                const text = await f.text();
                const lines = text.split('\n');
                const pts = [];
                for (let i = 0; i < lines.length; i++) {
                    const parts = lines[i].trim().split(/\s+/);
                    if (parts.length >= 3) {
                        const x = parseFloat(parts[0]);
                        if (x > 100000) {
                            pts.push({ x: x, y: parseFloat(parts[1]), z: parseFloat(parts[2]) });
                        }
                    }
                }
                layers.push({ name: f.name, points: pts });
            }
            renderThinInstances();
        }

        function renderThinInstances() {
            // æ¸…ç†
            scene.meshes.filter(m => m.name.startsWith("geoLayer")).forEach(m => m.dispose());
            if (layers.length === 0) return;

            // è‡ªåŠ¨è®¡ç®—ä¸­å¿ƒç‚¹
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            layers.forEach(l => l.points.forEach(p => {
                if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x;
                if(p.y < minY) minY = p.y; if(p.y > maxY) maxY = p.y;
            }));
            const midX = (minX + maxX) / 2, midY = (minY + maxY) / 2;

            layers.forEach((layer, idx) => {
                const sampledPoints = layer.points.filter((_, i) => i % step === 0);
                
                // åˆ›å»ºåŸºç¡€æ–¹å—ä½œä¸ºæ¯ä½“
                const baseBox = BABYLON.MeshBuilder.CreateBox("geoLayer_" + idx, { size: 1 }, scene);
                const mat = new BABYLON.StandardMaterial("mat" + idx, scene);
                const hue = (idx * 90) % 360;
                mat.diffuseColor = BABYLON.Color3.FromHSV(hue, 0.7, 1);
                mat.freeze(); // æè´¨å†·å†»æå‡æ€§èƒ½
                baseBox.material = mat;

                // æ ¸å¿ƒï¼šæ„å»º Thin Instance çŸ©é˜µç¼“å­˜
                const matricesData = new Float32Array(16 * sampledPoints.length);
                for (let i = 0; i < sampledPoints.length; i++) {
                    const p = sampledPoints[i];
                    // åˆ›å»ºä½ç§»çŸ©é˜µ
                    const matrix = BABYLON.Matrix.Translation(
                        p.x - midX,
                        p.z * (zFactor / 10),
                        p.y - midY
                    );
                    // ç¼©æ”¾æ–¹å—å¢åŠ ä½“ç§¯æ„Ÿ
                    const scale = BABYLON.Matrix.Scaling(boxSize, boxSize * 4, boxSize);
                    scale.multiplyToRef(matrix, matrix);
                    matrix.copyToArray(matricesData, i * 16);
                }
                
                baseBox.thinInstanceSetBuffer("matrix", matricesData, 16);
                baseBox.doNotSyncBoundingInfo = true; // è¿›ä¸€æ­¥ä¼˜åŒ–æ€§èƒ½
            });

            document.getElementById("info").innerText = `å·²æ¸²æŸ“: ${layers.length} å±‚åœ°è´¨ä½“`;
            camera.setTarget(BABYLON.Vector3.Zero());
        }

        // äº¤äº’é€»è¾‘
        document.getElementById('fileInput').onchange = (e) => loadFiles(e.target.files);
        
        document.getElementById('zScale').oninput = (e) => {
            zFactor = e.target.value;
            document.getElementById("zVal").innerText = zFactor;
            renderThinInstances();
        };

        document.getElementById('sample').oninput = (e) => {
            step = parseInt(e.target.value);
            document.getElementById("sVal").innerText = step;
            renderThinInstances();
        };

        document.getElementById('bSize').oninput = (e) => {
            boxSize = parseFloat(e.target.value);
            document.getElementById("bVal").innerText = boxSize;
            renderThinInstances();
        };

        document.getElementById('resetCam').onclick = () => camera.setTarget(BABYLON.Vector3.Zero());

        createScene().then(() => engine.runRenderLoop(() => scene.render()));
        window.addEventListener("resize", () => engine.resize());
    </script>
</body>
</html>