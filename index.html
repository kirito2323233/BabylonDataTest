<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>永城七采区 - 地质 VR 调试版</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        body, html { overflow: hidden; width: 100%; height: 100%; margin: 0; background: #111; color: white; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(0,0,0,0.85); padding: 15px; border-radius: 8px; font-family: sans-serif; width: 320px; border: 1px solid #444; }
        .debug-log { font-size: 11px; color: #aaa; margin-top: 10px; height: 100px; overflow-y: auto; background: #000; padding: 5px; }
        .control-group { margin: 10px 0; }
        button { cursor: pointer; padding: 5px 10px; }
    </style>
</head>
<body>
    <div id="ui">
        <strong>永城七采区 - 数据加载器</strong>
        <div class="control-group">
            <label>1. 选择文件 (支持多选):</label><br>
            <input type="file" id="fileInput" accept=".txt" multiple>
        </div>
        <div class="control-group">
            <label>2. 垂直拉伸: <span id="zVal">10</span>倍</label>
            <input type="range" id="zScale" min="1" max="50" value="10" style="width:100%">
        </div>
        <button id="resetCam">重置相机视角</button>
        <div id="status" style="color: #0f0; margin-top:5px;">状态: 等待文件...</div>
        <div id="log" class="debug-log">-- 运行日志 --</div>
    </div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const logDiv = document.getElementById("log");
        let scene, camera;
        let layers = []; 
        let zFactor = 10;

        function addLog(msg) {
            const p = document.createElement("div");
            p.innerText = `> ${msg}`;
            logDiv.prepend(p);
            console.log(msg);
        }

        const createScene = async function () {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.1);

            // 初始相机放在一个很远的位置，防止初始黑屏
            camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 100, BABYLON.Vector3.Zero(), scene);
            camera.setPosition(new BABYLON.Vector3(500, 500, 500));
            camera.attachControl(canvas, true);
            
            new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            
            // 辅助坐标轴
            const axes = new BABYLON.AxesViewer(scene, 50);

            try {
                await scene.createDefaultXRExperienceAsync({ floorMeshes: [] });
                addLog("WebXR VR 系统已就绪");
            } catch(e) {
                addLog("提示: 当前浏览器不支持直接进入VR模式");
            }
            return scene;
        };

        const colors = [
            new BABYLON.Color4(1, 1, 0, 1), // 黄
            new BABYLON.Color4(0, 1, 1, 1), // 青
            new BABYLON.Color4(1, 0, 1, 1), // 紫
            new BABYLON.Color4(0, 1, 0, 1)  // 绿
        ];

        async function parseData(file, idx) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const lines = e.target.result.split('\n');
                    const points = [];
                    addLog(`正在解析: ${file.name}...`);
                    
                    for (let line of lines) {
                        const cleanLine = line.trim();
                        if (!cleanLine || cleanLine.startsWith('!') || cleanLine.startsWith('FMASCI')) continue;
                        
                        const parts = cleanLine.split(/\s+/);
                        if (parts.length >= 3) {
                            const x = parseFloat(parts[0]);
                            const y = parseFloat(parts[1]);
                            const z = parseFloat(parts[2]);
                            // 过滤掉文件尾部的统计数据 (特征是 X 坐标远小于 UTM 坐标)
                            if (!isNaN(x) && x > 100000) {
                                points.push({ x, y, z });
                            }
                        }
                    }
                    addLog(`${file.name} 解析完成: ${points.length} 个点`);
                    resolve({ name: file.name, points, color: colors[idx % colors.length] });
                };
                reader.readAsText(file);
            });
        }

        async function renderLayers() {
            if (layers.length === 0) return;

            // 清理旧网格
            scene.meshes.filter(m => m.id.startsWith("layer_")).forEach(m => m.dispose());

            // 重新计算边界
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            layers.forEach(l => {
                l.points.forEach(p => {
                    if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                    if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
                });
            });

            const midX = (minX + maxX) / 2;
            const midY = (minY + maxY) / 2;

            layers.forEach((layer, i) => {
                const pcs = new BABYLON.PointsCloudSystem("layer_" + i, 4, scene);
                pcs.addPoints(layer.points.length, (particle, j) => {
                    const p = layer.points[j];
                    particle.position = new BABYLON.Vector3(
                        p.x - midX,
                        p.z * (zFactor / 10), // Z 轴垂直变换
                        p.y - midY
                    );
                    particle.color = layer.color;
                });
                pcs.buildMeshAsync();
            });

            addLog("三维场景更新成功");
            document.getElementById("status").innerText = `状态: 已加载 ${layers.length} 层`;
            
            // 自动对焦
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.radius = (maxX - minX) * 0.7;
        }

        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            
            layers = [];
            for(let i=0; i<files.length; i++) {
                const data = await parseData(files[i], i);
                if (data.points.length > 0) layers.push(data);
            }
            renderLayers();
        });

        document.getElementById('zScale').addEventListener('input', (e) => {
            zFactor = e.target.value;
            document.getElementById("zVal").innerText = zFactor;
            renderLayers();
        });

        document.getElementById('resetCam').onclick = () => {
            camera.setTarget(BABYLON.Vector3.Zero());
            addLog("相机已重置");
        };

        createScene().then(() => {
            engine.runRenderLoop(() => scene.render());
        });

        window.addEventListener("resize", () => engine.resize());
    </script>
</body>
</html>