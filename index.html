<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>地质可视化调试版 - 解决黑屏</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        body, html { overflow: hidden; width: 100%; height: 100%; margin: 0; background: #000; }
        #renderCanvas { width: 100%; height: 100%; }
        #ui { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: #0f0; padding: 15px; border-radius: 5px; font-family: monospace; border: 1px solid #444; }
        .btn { background: #222; color: #0f0; border: 1px solid #0f0; padding: 5px 10px; cursor: pointer; margin-top: 10px; display: block; }
    </style>
</head>
<body>
    <div id="ui">
        <strong>控制台 / 状态反馈</strong>
        <div id="log" style="margin: 10px 0; font-size: 12px; color: #ccc;">请选择文件...</div>
        <input type="file" id="fileInput" accept=".txt" multiple>
        <button class="btn" onclick="resetCamera()">强制重置相机对焦</button>
        <div style="font-size: 11px; color: #666; margin-top: 5px;">* 如果黑屏，请点击上方按钮</div>
    </div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let scene, camera;
        let allLayers = [];

        // 核心：动态中心点（不再硬编码）
        let center = { x: 0, y: 0, z: 0 };

        const createScene = function () {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.1, 1);

            // 初始化一个基础相机
            camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 100, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 1.0;

            // 坐标轴辅助 (红色X, 绿色Y, 蓝色Z)
            new BABYLON.AxesViewer(scene, 100);

            return scene;
        };

        // 统一文件解析逻辑
        async function parseFMASCI(file) {
            const text = await file.text();
            const lines = text.split('\n');
            const points = [];
            
            lines.forEach(line => {
                const parts = line.trim().split(/\s+/);
                // 校验：必须有三个以上数字，且第一个数字是UTM坐标（通常>100000）
                if (parts.length >= 3) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    const z = parseFloat(parts[2]);
                    if (!isNaN(x) && x > 100000) {
                        points.push({x, y, z});
                    }
                }
            });
            return points;
        }

        async function handleFiles(files) {
            const logEl = document.getElementById("log");
            logEl.innerText = "正在解析数据...";
            
            // 1. 清理场景
            scene.meshes.forEach(m => { if(m.name.startsWith("layer")) m.dispose(); });
            allLayers = [];

            // 2. 批量解析并寻找全场中心点
            let sumX = 0, sumY = 0, sumZ = 0, totalPts = 0;
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

            for (let file of files) {
                const pts = await parseFMASCI(file);
                if (pts.length > 0) {
                    allLayers.push({ name: file.name, data: pts });
                    pts.forEach(p => {
                        sumX += p.x; sumY += p.y; sumZ += p.z;
                        if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                        if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
                    });
                    totalPts += pts.length;
                }
            }

            if (totalPts === 0) {
                logEl.innerText = "错误：未识别到有效数据点！";
                return;
            }

            // 3. 计算中心（关键：解决黑屏）
            center.x = sumX / totalPts;
            center.y = sumY / totalPts;
            center.z = sumZ / totalPts;

            // 4. 渲染 Thin Instances
            allLayers.forEach((layer, idx) => {
                const mat = new BABYLON.StandardMaterial("mat" + idx, scene);
                mat.diffuseColor = BABYLON.Color3.FromHSV(idx * 60, 0.8, 1);
                
                const box = BABYLON.MeshBuilder.CreateBox("layer_" + idx, { size: 5 }, scene);
                box.material = mat;

                const matricesData = new Float32Array(16 * layer.data.length);
                layer.data.forEach((p, i) => {
                    // 相对于中心点的位移
                    const matrix = BABYLON.Matrix.Translation(p.x - center.x, p.z - center.z, p.y - center.y);
                    matrix.copyToArray(matricesData, i * 16);
                });
                box.thinInstanceSetBuffer("matrix", matricesData, 16);
            });

            logEl.innerText = `成功！加载 ${allLayers.length} 层，共 ${totalPts} 点。`;
            resetCamera(maxX - minX);
        }

        function resetCamera(range = 500) {
            if (!camera) return;
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.radius = range > 500 ? range * 0.8 : 500;
            camera.alpha = -Math.PI / 2;
            camera.beta = Math.PI / 3;
            console.log("相机已对焦至中心 (0,0,0)");
        }

        document.getElementById('fileInput').onchange = (e) => handleFiles(e.target.files);

        scene = createScene();
        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());
    </script>
</body>
</html>